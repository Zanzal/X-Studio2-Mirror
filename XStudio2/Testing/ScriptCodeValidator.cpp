#include "stdafx.h"
#include "ScriptValidator.h"

namespace Testing
{
   namespace Scripts
   {
   
      // -------------------------------- CONSTRUCTION --------------------------------

      /// <summary>Creates source value read from an input stream</summary>
      /// <param name="src">The input stream</param>
      /// <exception cref="Logic::ArgumentException">Stream is not readable</exception>
      /// <exception cref="Logic::ArgumentNullException">Stream is null</exception>
      /// <exception cref="Logic::ComException">COM Error</exception>
      /// <exception cref="Logic::FileFormatException">File format is corrupt</exception>
      /// <exception cref="Logic::IOException">An I/O error occurred</exception>
      ScriptCodeValidator::ScriptCodeValidator(StreamPtr orig, StreamPtr copy)
         : In(orig), Out(copy)
      {
      }

      // ------------------------------- STATIC METHODS -------------------------------
      
      // ------------------------------- PUBLIC METHODS -------------------------------
      
      /// <summary>Perform comparison of commands generated by compiler between script and it's validation copy</summary>
      bool  ScriptCodeValidator::Compare()
      {
         // Properties
         Compare(In.CodeArray, Out.CodeArray, 0, L"script name");
         Compare(In.CodeArray, Out.CodeArray, 1, L"script engine version");
         Compare(In.CodeArray, Out.CodeArray, 2, L"script description");
         Compare(In.CodeArray, Out.CodeArray, 3, L"script version");
         Compare(In.CodeArray, Out.CodeArray, 4, L"script live data flag");
         Compare(In.CodeArray, Out.CodeArray, 9, L"script command ID");


         // Variables/Arguments count
         if (In.Variables.Count != Out.Variables.Count)
            throw CodeMismatch(HERE, L"script variable count", In.Variables.Count, Out.Variables.Count);

         // Variables/Arguments
         else for (auto v1 = In.Variables.begin(), v2 = Out.Variables.begin(); v1 != In.Variables.end(); ++v1, ++v2)
            Compare(*v1, *v2);

         // Command count
         if (In.Commands.Input.size() != Out.Commands.Input.size())
            throw CodeMismatch(HERE, L"script command count", In.Commands.Input.size(), Out.Commands.Input.size());
         else 
         {
            UINT line = 1;
            // Commands
            for (auto c1 = In.Commands.Input.begin(), c2 = Out.Commands.Input.begin(); c1 != In.Commands.Input.end(); ++c1, ++c2)
            {
               Compare(line, *c1, *c2);
               ++line;
            }
         }

         return true;
      }

      // ------------------------------ PROTECTED METHODS -----------------------------

      // ------------------------------- PRIVATE METHODS ------------------------------
      
      /// <summary>Perform comparison of two nodes</summary>
      bool  ScriptCodeValidator::Compare(XmlNodePtr parent_in, XmlNodePtr parent_out, UINT index, const wchar* help)
      {
         // Read nodes
         auto v1 = In.ReadValue(parent_in, index, help);
         auto v2 = Out.ReadValue(parent_out, index, help);

         // Compare content
         if (v1 != v2)
            throw CodeMismatch(HERE, help, v1, v2);
      }








      
      /// <summary>Perform textual comparison of a script and it's validation copy</summary>
      /// <param name="In">original script</param>
      /// <param name="Out">compiled copy</param>
      bool  ScriptCodeValidator::Compare(const LineArray& In, const LineArray& Out)
      {
         // Variables/Arguments count
         if (In.size() != Out.size())
            throw CodeMismatch(HERE, L"command count", GuiString(L"%d", In.size()), GuiString(L"%d", Out.size()));

         else 
         {
            UINT line = 1;
            for (auto c1 = In.begin(), c2 = Out.begin(); c1 != In.end(); ++c1, ++c2)
            {
               // Skip comparison of comments
               /*if (!c1->empty() && !c2->empty() && c1->front() == '*' && c2->front() == '*')
                  continue;*/
               // Compare command text
               if (*c1 != *c2)
                  throw CodeMismatch(HERE, GuiString(L"(line %d) command text", line), *c1, *c2);
            
               ++line;
            }
         }

         return true;
      }


      /// <summary>Perform textual comparison two script variables</summary>
      /// <param name="In">original variable</param>
      /// <param name="Out">compiled copy</param>
      bool  ScriptCodeValidator::Compare(const ScriptVariable& In, const ScriptVariable& Out)
      {
         try
         {
            if (In.Name != Out.Name)
               throw CodeMismatch(HERE, GuiString(L"Arg/Var Name (id=%d)", In.ID), In.Name, Out.Name);
            if (In.ID != Out.ID)
               throw CodeMismatch(HERE, GuiString(L"Arg/Var ID '%s'", In.Name.c_str()), In.ID, Out.ID);
            if (In.Type != Out.Type)
               throw CodeMismatch(HERE, GuiString(L"Arg/Var type flag of '%s'", In.Name.c_str()), GetString(In.Type), GetString(Out.Type));

            if (In.Description != Out.Description)
               throw CodeMismatch(HERE, GuiString(L"Argument description '%s'", In.Name.c_str()), In.Description, Out.Description);
            if (In.ValueType != Out.ValueType)
               throw CodeMismatch(HERE, GuiString(L"Argument Type '%s'", In.Name.c_str()), GetString(In.ValueType), GetString(Out.ValueType));
         }
         catch (ExceptionBase&)
         {
            Console << "Orig: " << In << ENDL;
            Console << "Copy: " << Out << ENDL;
            throw;
         }

         return true;
      }

      /// <summary>Perform textual comparison of two script commands</summary>
      /// <param name="line">1-based line number</param>
      /// <param name="In">original commands</param>
      /// <param name="Out">compiled copy</param>
      bool  ScriptCodeValidator::Compare(UINT line, const ScriptCommand& In, const ScriptCommand& Out)
      {
         // Syntax + Text
         if (In.Syntax != Out.Syntax)
            throw CodeMismatch(HERE, GuiString(L"(line %d) command syntax", line), In.Syntax.Text, Out.Syntax.Text);
         if (In.Text != Out.Text)
            throw CodeMismatch(HERE, GuiString(L"(line %d) command text", line), In.Text, Out.Text);

         // Parameter count
         if (In.Parameters.size() != Out.Parameters.size())
            throw CodeMismatch(HERE, GuiString(L"(line %d) parameter count", line), In.Parameters.size(), Out.Parameters.size());
         else 
         {
            UINT param = 1;

            // Parameters
            for (auto p1 = In.Parameters.begin(), p2 = Out.Parameters.begin(); p1 != In.Parameters.end(); ++p1, ++p2)
            {
               Compare(line, param, *p1, *p2);
               ++param;
            }
         }
         
         return true;
      }

      /// <summary>Perform textual comparison of two script parameters</summary>
      /// <param name="line">1-based line number</param>
      /// <param name="param">1-based parameter index</param>
      /// <param name="In">original parameter</param>
      /// <param name="Out">compiled copy</param>
      bool  ScriptCodeValidator::Compare(UINT line, UINT param, const ScriptParameter& In, const ScriptParameter& Out)
      {
         try
         {
            // Type
            if (In.Syntax.Type != Out.Syntax.Type)
               throw CodeMismatch(HERE, GuiString(L"(line %d, param %d) syntax", line, param), GetString(In.Syntax.Type), GetString(Out.Syntax.Type));

            // Text
            if (In.Text != Out.Text)
               throw CodeMismatch(HERE, GuiString(L"(line %d, param %d) text", line, param), In.Text, Out.Text);

            // Value
            if (In.Value.Type != Out.Value.Type)
               throw CodeMismatch(HERE, GuiString(L"(line %d, param %d) value type", line, param), GetString(In.Value.Type), GetString(Out.Value.Type));

            else if (In.Value.Type == ValueType::Int && In.Value.Int != Out.Value.Int)
               throw CodeMismatch(HERE, GuiString(L"(line %d, param %d) value", line, param), In.Value.Int, Out.Value.Int);

            else if (In.Value.Type == ValueType::String && In.Value.String != Out.Value.String)
               throw CodeMismatch(HERE, GuiString(L"(line %d, param %d) value", line, param), In.Value.String, Out.Value.String);
         }
         catch (ExceptionBase&)
         {
            Console << "Orig: " << In << ENDL;
            Console << "Copy: " << Out << ENDL;
            throw;
         }

         return true;
      }

      /// <summary>Create text mismatch exception</summary>
      /// <param name="src">throw source.</param>
      /// <param name="prop">name of property that mismatches</param>
      /// <param name="a">original</param>
      /// <param name="b">copy</param>
      /// <returns></returns>
      ValidationException  ScriptCodeValidator::CodeMismatch(const GuiString& src, const GuiString& prop, const GuiString& a, const GuiString& b)
      {
         return ValidationException(src, GuiString(L"%s mismatch: original='%s'\ncopy='%s'", prop.c_str(), a.c_str(), b.c_str()) );
      }

      /// <summary>Create text mismatch exception</summary>
      /// <param name="src">throw source.</param>
      /// <param name="prop">name of property that mismatches</param>
      /// <param name="a">original</param>
      /// <param name="b">copy</param>
      /// <returns></returns>
      ValidationException  ScriptCodeValidator::CodeMismatch(const GuiString& src, const GuiString& prop, const ParameterValue& a, const ParameterValue& b)
      {
         return ValidationException(src, GuiString(L"%s mismatch: original='%s'\ncopy='%s'", prop.c_str(), a.ToString().c_str(), b.ToString().c_str()) );
      }
      
      /// <summary>Create text mismatch exception</summary>
      /// <param name="src">throw source.</param>
      /// <param name="prop">name of property that mismatches</param>
      /// <param name="a">original</param>
      /// <param name="b">copy</param>
      /// <returns></returns>
      ValidationException  ScriptCodeValidator::CodeMismatch(const GuiString& src, const GuiString& prop, int a, int b)
      {
         return ValidationException(src, GuiString(L"%s mismatch: original='%s'\ncopy='%s'", prop.c_str(), GuiString(L"%d",a).c_str(), GuiString(L"%d",b).c_str()) );
      }
   }
}

