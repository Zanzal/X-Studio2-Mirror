#include "stdafx.h"
#include "ScriptValidator.h"
#include "../Logic/SyntaxLibrary.h"

namespace Testing
{
   namespace Scripts
   {
   
      // -------------------------------- CONSTRUCTION --------------------------------

      /// <summary>Creates source value read from an input stream</summary>
      /// <param name="src">The input stream</param>
      /// <exception cref="Logic::ArgumentException">Stream is not readable</exception>
      /// <exception cref="Logic::ArgumentNullException">Stream is null</exception>
      /// <exception cref="Logic::ComException">COM Error</exception>
      /// <exception cref="Logic::FileFormatException">File format is corrupt</exception>
      /// <exception cref="Logic::IOException">An I/O error occurred</exception>
      ScriptCodeValidator::ScriptCodeValidator(StreamPtr orig, StreamPtr copy)
         : In(orig), Out(copy)
      {
      }

      // ------------------------------- STATIC METHODS -------------------------------
      
      /// <summary>Create text mismatch exception</summary>
      /// <param name="src">throw source.</param>
      /// <param name="prop">name of property that mismatches</param>
      /// <param name="a">original</param>
      /// <param name="b">copy</param>
      /// <returns></returns>
      ValidationException  ScriptCodeValidator::CodeMismatch(const GuiString& src, const GuiString& prop, const GuiString& a, const GuiString& b)
      {
         return ValidationException(src, GuiString(L"code mismatch: %s\n  original='%s'\n  copy='%s'\n", prop.c_str(), a.c_str(), b.c_str()) );
      }

      /// <summary>Create text mismatch exception</summary>
      /// <param name="src">throw source.</param>
      /// <param name="prop">name of property that mismatches</param>
      /// <param name="a">original</param>
      /// <param name="b">copy</param>
      /// <returns></returns>
      ValidationException  ScriptCodeValidator::CodeMismatch(const GuiString& src, const GuiString& prop, const ParameterValue& a, const ParameterValue& b)
      {
         GuiString v1 = (a.Type == ValueType::String ? a.String : GuiString(L"0x%08X  (%d)", a.Int, a.Int));
         GuiString v2 = (b.Type == ValueType::String ? b.String : GuiString(L"0x%08X  (%d)", b.Int, b.Int));

         return CodeMismatch(src, prop, v1, v2);
      }
      
      /// <summary>Create text mismatch exception</summary>
      /// <param name="src">throw source.</param>
      /// <param name="prop">name of property that mismatches</param>
      /// <param name="a">original</param>
      /// <param name="b">copy</param>
      /// <returns></returns>
      ValidationException  ScriptCodeValidator::CodeMismatch(const GuiString& src, const GuiString& prop, int a, int b)
      {
         auto v1 = GuiString(L"0x%08X  (%d)", a, a);
         auto v2 = GuiString(L"0x%08X  (%d)", b, b);

         return CodeMismatch(src, prop, v1, v2);
      }

      // ------------------------------- PUBLIC METHODS -------------------------------
      
      /// <summary>Perform comparison of commands generated by compiler between script and it's validation copy</summary>
      bool  ScriptCodeValidator::Compare()
      {
         // Properties
         Compare(In.CodeArray, Out.CodeArray, 0, L"script name");
         //Compare(In.CodeArray, Out.CodeArray, 1, L"script engine version");
         Compare(In.CodeArray, Out.CodeArray, 2, L"script description");
         Compare(In.CodeArray, Out.CodeArray, 3, L"script version");
         Compare(In.CodeArray, Out.CodeArray, 4, L"script live data flag");
         //Compare(In.CodeArray, Out.CodeArray, 9, L"script command ID");

         // Data + Code
         CompareVariables();
         CompareArguments();
         CompareCommands();
         return true;
      }

      // ------------------------------ PROTECTED METHODS -----------------------------

      // ------------------------------- PRIVATE METHODS ------------------------------
      
      /// <summary>Compare type and value of two nodes</summary>
      bool  ScriptCodeValidator::Compare(XmlNodePtr parent_in, XmlNodePtr parent_out, UINT index, GuiString help)
      {
         // Read nodes
         auto v1 = In.ReadValue(parent_in, index, help.c_str());
         auto v2 = Out.ReadValue(parent_out, index, help.c_str());

         // Compare content
         if (v1 != v2)
            throw CodeMismatch(HERE, help, v1, v2);

         return true;
      }

      /// <summary>Compare argument branches</summary>
      void  ScriptCodeValidator::CompareArguments()
      {
         // Branch size
         CompareSize(In.CodeArray, Out.CodeArray, 7, L"arguments branch size");

         // Arguments
         auto in_args = In.GetChild(In.CodeArray, 7, L"arguments branch");
         auto out_args = Out.GetChild(Out.CodeArray, 7, L"arguments branch");

         for (int i = 0; i < in_args->childNodes->length; i++)
         {
            // Property count
            CompareSize(in_args, out_args, i, GuiString(L"argument %d sub-branch size", i+1));
            
            // Get sub-branch
            auto in_arg = In.GetChild(in_args, i, GuiString(L"argument %d sub-branch", i+1).c_str());
            auto out_arg = Out.GetChild(out_args, i, GuiString(L"argument %d sub-branch", i+1).c_str());
            
            // argument type/description
            Compare(in_arg, out_arg, 0, GuiString(L"argument %d type", i+1));
            Compare(in_arg, out_arg, 1, GuiString(L"argument %d description", i+1));
         }
      }

      /// <summary>Compare standard command branches</summary>
      void  ScriptCodeValidator::CompareCommands()
      {
         // Verify branch sizes
         CompareSize(In.CodeArray, Out.CodeArray, 6, L"std commands branch size");
         //CompareSize(In.CodeArray, Out.CodeArray, 8, L"aux commands branch size");

         // Std Commands
         auto in_cmds = In.GetChild(In.CodeArray, 6, L"std commands branch");
         auto out_cmds = Out.GetChild(Out.CodeArray, 6, L"std commands branch");

         for (int i = 0; i < in_cmds->childNodes->length; i++)
         {
            auto line = GuiString(L"(std %d) : ", i+1);
            bool errors = false;

            // Get command branch
            auto in_cmd = In.GetChild(in_cmds, i, (line+L"sub-branch").c_str());
            auto out_cmd = Out.GetChild(out_cmds, i, (line+L"sub-branch").c_str());

            // Get command ID
            Compare(in_cmd, out_cmd, 0, line + L"command ID");
            CommandSyntax syntax = SyntaxLib.Find(In.ReadInt(in_cmd, 0, (line+L"command ID").c_str()), GameVersion::TerranConflict);

            // Improve location description
            line = GuiString(L"(std %d) '%s' : ", i+1, syntax.Text.c_str());

            // Node count
            CompareSize(in_cmds, out_cmds, i, line+L"node count");
            
            // parameters
            UINT nodeIndex = 1, paramIndex = 1;
            for (ParameterSyntax p : syntax.Parameters)
            {
               GuiString paramId(line + GuiString(L" param %d of %d : ", paramIndex++, syntax.Parameters.size()) + GetString(p.Type));
               DataType  dt = DataType::UNKNOWN;

               try
               {
                  switch (p.Type)
                  {
                  // Single node
                  case ParameterType::COMMENT:        
                  case ParameterType::SCRIPT_NAME:    
                  case ParameterType::LABEL_NAME:     
                  case ParameterType::LABEL_NUMBER: 
                  case ParameterType::VARIABLE:          // Old 'var' parameter
                  case ParameterType::RETURN_VALUE:      
                  case ParameterType::RETURN_VALUE_IF:
                  case ParameterType::RETURN_VALUE_IF_START:
                  case ParameterType::INTERRUPT_RETURN_VALUE_IF: 
                     Compare(in_cmd, out_cmd, nodeIndex, paramId);
                     break;
                        
                  // Parameter as {Type,Value} pair
                  default:
                     dt = (DataType)In.ReadInt(in_cmd, nodeIndex, (paramId+L" DataType").c_str());

                     Compare(in_cmd, out_cmd, nodeIndex, line+paramId+GetString(p.Type)+L" (type)");
                     Compare(in_cmd, out_cmd, nodeIndex, line+paramId+GetString(p.Type)+L" (value)");
                        
                     ++nodeIndex;
                     break;
                  }
               }
               // Comparison failed: Print details of value
               catch (ValidationException& e) 
               {
                  Console.Log(HERE, e);
                  errors = true;

                  // Read values
                  int in_val  = In.ReadInt(in_cmd, nodeIndex, (paramId+L" Value").c_str()),
                      out_val = In.ReadInt(out_cmd, nodeIndex, (paramId+L" Value").c_str());
                     
                  // Print Variable names
                  switch (p.Type)
                  {
                  case ParameterType::COMMENT:        
                  case ParameterType::SCRIPT_NAME:    
                  case ParameterType::LABEL_NAME:     
                  case ParameterType::LABEL_NUMBER: 
                     break;

                  // Var/RetVar
                  case ParameterType::VARIABLE:          // Old 'var' parameter
                  case ParameterType::RETURN_VALUE:      
                  case ParameterType::RETURN_VALUE_IF:
                  case ParameterType::RETURN_VALUE_IF_START:
                  case ParameterType::INTERRUPT_RETURN_VALUE_IF: 
                     // Return Value: Print components
                     if (in_val < 0 || out_val < 0)  
                     {
                        Console << L"  Original RetVal: " << ReturnValue(in_val) << ENDL;
                        Console << L"  Copy RetVal: " << ReturnValue(out_val) << ENDL;
                        break;
                     }
                     else // RetVar: Print names
                        dt = DataType::VARIABLE;
                        // Fall thru...

                  // Parameter as {Type,Value} pair
                  default:
                     // Variable: Print names
                     if (dt == DataType::VARIABLE && in_val >= 0 && out_val >= 0)
                     {
                        Console << L"  Original var: " << InVars[in_val] << ENDL;
                        Console << L"  Copy var: " << OutVars[out_val] << ENDL;
                     }

                     ++nodeIndex;  // Re-align node index
                     break;
                  }
               }

               ++nodeIndex;
            }

            // Errors: Abort after printing all invalid parameters
            if (errors)
               throw GenericException(HERE, L"Stopping validation due to errors");
         }
      }


      /// <summary>Compare size of two array nodes</summary>
      bool  ScriptCodeValidator::CompareSize(XmlNodePtr parent_in, XmlNodePtr parent_out, UINT index, GuiString help)
      {
         // Read sizes
         auto v1 = In.ReadArray(parent_in, index, help.c_str());
         auto v2 = Out.ReadArray(parent_out, index, help.c_str());

         // Compare size
         if (v1 != v2)
            throw CodeMismatch(HERE, help, v1, v2);

         return true;
      }

      
      /// <summary>Compare variables branches</summary>
      void  ScriptCodeValidator::CompareVariables()
      {
         // Verify branch size
         CompareSize(In.CodeArray, Out.CodeArray, 5, L"variables branch size");

         // Get branches
         auto in_vars = In.GetChild(In.CodeArray, 5, L"variables branch");
         auto out_vars = Out.GetChild(Out.CodeArray, 5, L"variables branch");

         // Compare names/order
         for (int i = 0; i < in_vars->childNodes->length; i++)
         {
            Compare(in_vars, out_vars, i, GuiString(L"variable %d of %d", i+1, in_vars->childNodes->length));

            // Store for name resolution
            InVars.push_back( ScriptVariable(In.ReadString(in_vars, i, L"variable name"), i) );
            OutVars.push_back( ScriptVariable(Out.ReadString(out_vars, i, L"variable name"), i) );
         }
         
      }

   }
}

