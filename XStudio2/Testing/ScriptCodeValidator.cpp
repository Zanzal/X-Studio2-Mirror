#include "stdafx.h"
#include "ScriptValidator.h"

namespace Testing
{
   namespace Scripts
   {
   
      // -------------------------------- CONSTRUCTION --------------------------------

      /// <summary>Creates source value read from an input stream</summary>
      /// <param name="src">The input stream</param>
      /// <exception cref="Logic::ArgumentException">Stream is not readable</exception>
      /// <exception cref="Logic::ArgumentNullException">Stream is null</exception>
      /// <exception cref="Logic::ComException">COM Error</exception>
      /// <exception cref="Logic::FileFormatException">File format is corrupt</exception>
      /// <exception cref="Logic::IOException">An I/O error occurred</exception>
      ScriptCodeValidator::ScriptCodeValidator(StreamPtr orig, StreamPtr copy)
         : In(orig), Out(copy)
      {
      }

      // ------------------------------- STATIC METHODS -------------------------------
      
      /// <summary>Create text mismatch exception</summary>
      /// <param name="src">throw source.</param>
      /// <param name="prop">name of property that mismatches</param>
      /// <param name="a">original</param>
      /// <param name="b">copy</param>
      /// <returns></returns>
      ValidationException  ScriptCodeValidator::CodeMismatch(const GuiString& src, const GuiString& prop, const GuiString& a, const GuiString& b)
      {
         return ValidationException(src, GuiString(L"%s code mismatch:\n  original='%s'\n  copy='%s'", prop.c_str(), a.c_str(), b.c_str()) );
      }

      /// <summary>Create text mismatch exception</summary>
      /// <param name="src">throw source.</param>
      /// <param name="prop">name of property that mismatches</param>
      /// <param name="a">original</param>
      /// <param name="b">copy</param>
      /// <returns></returns>
      ValidationException  ScriptCodeValidator::CodeMismatch(const GuiString& src, const GuiString& prop, const ParameterValue& a, const ParameterValue& b)
      {
         GuiString v1 = (a.Type == ValueType::String ? a.String : GuiString(L"0x%X  (%d)", a.Int, a.Int));
         GuiString v2 = (b.Type == ValueType::String ? b.String : GuiString(L"0x%X  (%d)", b.Int, b.Int));

         return CodeMismatch(src, prop, v1, v2);
      }
      
      /// <summary>Create text mismatch exception</summary>
      /// <param name="src">throw source.</param>
      /// <param name="prop">name of property that mismatches</param>
      /// <param name="a">original</param>
      /// <param name="b">copy</param>
      /// <returns></returns>
      ValidationException  ScriptCodeValidator::CodeMismatch(const GuiString& src, const GuiString& prop, int a, int b)
      {
         auto v1 = GuiString(L"0x%X  (%d)", a, a);
         auto v2 = GuiString(L"0x%X  (%d)", b, b);

         return CodeMismatch(src, prop, v1, v2);
      }

      // ------------------------------- PUBLIC METHODS -------------------------------
      
      /// <summary>Perform comparison of commands generated by compiler between script and it's validation copy</summary>
      bool  ScriptCodeValidator::Compare()
      {
         // Properties
         Compare(In.CodeArray, Out.CodeArray, 0, L"script name");
         //Compare(In.CodeArray, Out.CodeArray, 1, L"script engine version");
         Compare(In.CodeArray, Out.CodeArray, 2, L"script description");
         Compare(In.CodeArray, Out.CodeArray, 3, L"script version");
         Compare(In.CodeArray, Out.CodeArray, 4, L"script live data flag");
         Compare(In.CodeArray, Out.CodeArray, 9, L"script command ID");

         // Verify branch sizes
         CompareSize(In.CodeArray, Out.CodeArray, 5, L"variables branch size");
         CompareSize(In.CodeArray, Out.CodeArray, 7, L"arguments branch size");
         CompareSize(In.CodeArray, Out.CodeArray, 6, L"std commands branch size");
         CompareSize(In.CodeArray, Out.CodeArray, 8, L"aux commands branch size");

         // Variables
         auto in_vars = In.GetChild(In.CodeArray, 5, L"variables branch");
         auto out_vars = Out.GetChild(Out.CodeArray, 5, L"variables branch");

         for (int i = 0; i < in_vars->childNodes->length; i++)
            Compare(in_vars, out_vars, i, L"variable declaration");

         // Arguments
         auto in_args = In.GetChild(In.CodeArray, 7, L"arguments branch");
         auto out_args = Out.GetChild(Out.CodeArray, 7, L"arguments branch");

         for (int i = 0; i < in_args->childNodes->length; i++)
         {
            // Property count
            CompareSize(in_args, out_args, i, L"argument sub-branch size");
            
            // Get sub-branch
            auto in_arg = In.GetChild(in_args, i, L"argument sub-branch");
            auto out_arg = Out.GetChild(out_args, i, L"argument sub-branch");
            
            // argument type/description
            Compare(in_arg, out_arg, 0, L"argument type");
            Compare(in_arg, out_arg, 1, L"argument description");
         }

         // Std Commands
         auto in_cmds = In.GetChild(In.CodeArray, 6, L"std commands branch");
         auto out_cmds = Out.GetChild(Out.CodeArray, 6, L"std commands branch");

         for (int i = 0; i < in_cmds->childNodes->length; i++)
         {
            // Node count
            CompareSize(in_cmds, out_cmds, i, L"std command sub-branch size");
            
            // Get sub-branch
            auto in_cmd = In.GetChild(in_cmds, i, L"std command sub-branch");
            auto out_cmd = Out.GetChild(out_cmds, i, L"std command sub-branch");
            
            // Nodes
            for (int i = 0; i < in_cmd->childNodes->length; i++)
               Compare(in_cmd, out_cmd, i, L"std command component node");
         }

         return true;
      }

      // ------------------------------ PROTECTED METHODS -----------------------------

      // ------------------------------- PRIVATE METHODS ------------------------------
      
      /// <summary>Compare type and value of two nodes</summary>
      bool  ScriptCodeValidator::Compare(XmlNodePtr parent_in, XmlNodePtr parent_out, UINT index, const wchar* help)
      {
         // Read nodes
         auto v1 = In.ReadValue(parent_in, index, help);
         auto v2 = Out.ReadValue(parent_out, index, help);

         // Compare content
         if (v1 != v2)
            throw CodeMismatch(HERE, help, v1, v2);

         return true;
      }

      /// <summary>Compare size of two array nodes</summary>
      bool  ScriptCodeValidator::CompareSize(XmlNodePtr parent_in, XmlNodePtr parent_out, UINT index, const wchar* help)
      {
         // Read sizes
         auto v1 = In.ReadArray(parent_in, index, help);
         auto v2 = Out.ReadArray(parent_out, index, help);

         // Compare size
         if (v1 != v2)
            throw CodeMismatch(HERE, help, v1, v2);

         return true;
      }

   }
}

